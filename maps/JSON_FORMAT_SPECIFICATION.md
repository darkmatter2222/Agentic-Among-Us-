# Among Us Map JSON Format Specification

## Overview

This document provides a complete specification for reading and implementing Among Us map JSON files generated by the map editor. All maps use JSON format version 2.0 with precise coordinate-based geometry.

---

## File Structure

```json
{
  "metadata": { },
  "walls": [ ],
  "walkableZones": [ ],
  "labeledZones": [ ],
  "vents": [ ],
  "doors": [ ],
  "tasks": [ ],
  "cameras": [ ]
}
```

---

## Coordinate System

### Units
- **All coordinates are in pixels** relative to the source PNG image
- Coordinate origin (0, 0) is at the **top-left corner** of the image
- X increases rightward, Y increases downward
- All measurements are in pixel units unless otherwise specified

### Distance Calculations
```javascript
// Euclidean distance between two points
distance = Math.sqrt((x2 - x1)² + (y2 - y1)²)

// Example: Kill range = 2.5 units = 2.5 pixels
```

### Scale Factor
- The JSON coordinates are **1:1 pixel scale** from the editor
- Game engine should maintain aspect ratio when rendering
- Recommended: Scale entire map proportionally to fit game viewport

---

## 1. Metadata

```json
"metadata": {
  "image": "filename.png",
  "version": "2.0"
}
```

| Field | Type | Description |
|-------|------|-------------|
| `image` | `string` | Filename of the source PNG background image |
| `version` | `string` | JSON format version (currently "2.0") |

**Implementation Notes:**
- Use `image` to load the background texture/sprite
- Version 2.0 includes `labeledZones` and `holes` features

---

## 2. Walls (CURRENTLY UNUSED)

```json
"walls": []
```

**Status:** Deprecated in current workflow. Walls are now defined implicitly as boundaries between walkable zones and holes.

**Implementation:** Can ignore this array. Movement boundaries are defined by walkableZones and their holes.

---

## 3. Walkable Zones (Player Movement Areas)

```json
"walkableZones": [
  {
    "vertices": [
      {"x": 590.13, "y": 444.35},
      {"x": 590.13, "y": 668.28},
      ...
    ],
    "isRoom": false,
    "roomName": "",
    "holes": [
      [
        {"x": 800.0, "y": 500.0},
        {"x": 850.0, "y": 500.0},
        ...
      ]
    ]
  }
]
```

### Fields

| Field | Type | Description |
|-------|------|-------------|
| `vertices` | `Point[]` | Ordered array of polygon vertices defining the walkable boundary |
| `isRoom` | `boolean` | Legacy field - **DEPRECATED**, use `labeledZones` instead |
| `roomName` | `string` | Legacy field - **DEPRECATED**, use `labeledZones` instead |
| `holes` | `Point[][]` | Array of obstacle polygons (walls/barriers inside the zone) |

### Point Format
```json
{"x": <number>, "y": <number>}
```

### Implementation Details

#### Polygon Rendering
```javascript
// Vertices form a closed polygon
// Connect: vertices[0] → vertices[1] → ... → vertices[n-1] → vertices[0]

// Render as filled polygon for walkable area
ctx.beginPath();
ctx.moveTo(vertices[0].x, vertices[0].y);
for (let i = 1; i < vertices.length; i++) {
  ctx.lineTo(vertices[i].x, vertices[i].y);
}
ctx.closePath();
ctx.fill(); // Fill with walkable area color
```

#### Holes (Obstacles)
```javascript
// Each hole is a polygon that subtracts from the walkable zone
// Use composite operations or path subtraction

for (const hole of zone.holes) {
  ctx.beginPath();
  ctx.moveTo(hole[0].x, hole[0].y);
  for (let i = 1; i < hole.length; i++) {
    ctx.lineTo(hole[i].x, hole[i].y);
  }
  ctx.closePath();
  // This area is NOT walkable (wall/obstacle)
}
```

#### Movement Collision Detection
```javascript
function canMoveTo(fromX, fromY, toX, toY) {
  // 1. Check if destination is inside any walkable zone
  let insideWalkableZone = false;
  
  for (const zone of walkableZones) {
    if (pointInPolygon(toX, toY, zone.vertices)) {
      insideWalkableZone = true;
      
      // 2. Check if destination is NOT inside any hole
      for (const hole of zone.holes) {
        if (pointInPolygon(toX, toY, hole)) {
          return false; // Inside a hole (obstacle)
        }
      }
      break;
    }
  }
  
  if (!insideWalkableZone) {
    return false; // Outside all walkable zones
  }
  
  // 3. Check if movement path crosses any zone boundaries or holes
  for (const zone of walkableZones) {
    // Check zone boundary crossings
    if (lineCrossesPolygon(fromX, fromY, toX, toY, zone.vertices)) {
      return false;
    }
    
    // Check hole boundary crossings
    for (const hole of zone.holes) {
      if (lineCrossesPolygon(fromX, fromY, toX, toY, hole)) {
        return false;
      }
    }
  }
  
  return true;
}
```

#### Point-in-Polygon Algorithm
```javascript
function pointInPolygon(x, y, vertices) {
  let inside = false;
  for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
    const xi = vertices[i].x, yi = vertices[i].y;
    const xj = vertices[j].x, yj = vertices[j].y;
    
    const intersect = ((yi > y) !== (yj > y))
        && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}
```

---

## 4. Labeled Zones (Player Location Detection)

```json
"labeledZones": [
  {
    "vertices": [
      {"x": 363.06, "y": 677.37},
      {"x": 363.06, "y": 1020.10},
      ...
    ],
    "name": "Reactor"
  }
]
```

### Fields

| Field | Type | Description |
|-------|------|-------------|
| `vertices` | `Point[]` | Ordered array of polygon vertices defining the zone boundary |
| `name` | `string` | Display name of the zone (e.g., "Cafeteria", "MedBay", "Reactor") |

### Purpose
- **Player Location Detection:** Determines which room/area the player is currently in
- **UI Display:** Shows "You are in: [name]" to the player
- **Game Logic:** Used for reporting body locations, task assignments, emergency meeting context

### Implementation

```javascript
function getCurrentZone(playerX, playerY) {
  for (const zone of labeledZones) {
    if (pointInPolygon(playerX, playerY, zone.vertices)) {
      return zone.name; // e.g., "Reactor", "Cafeteria"
    }
  }
  return null; // Not in any labeled zone
}
```

### Important Notes
- Labeled zones can **overlap** (e.g., doorways might be in multiple zones)
- Priority: First matching zone in array order
- Zones can extend **beyond walkable areas** (e.g., for transition detection)
- Zone names match canonical Among Us room names from the game

### Common Zone Names (The Skeld)
- Upper Engine
- Lower Engine
- Reactor
- Security
- MedBay
- Electrical
- Cafeteria
- Storage
- Admin
- Communications
- O2
- Navigation
- Weapons
- Shields

---

## 5. Vents (Impostor Vent System)

```json
"vents": [
  {
    "id": "vent_1",
    "position": {"x": 802.39, "y": 418.69},
    "connectedTo": ["vent_2"]
  }
]
```

### Fields

| Field | Type | Description |
|-------|------|-------------|
| `id` | `string` | Unique identifier for the vent |
| `position` | `Point` | Center position of the vent on the map |
| `connectedTo` | `string[]` | Array of vent IDs this vent connects to |

### Vent Network Mechanics

#### Connectivity
- Vents form a **directed graph** (can be bidirectional or one-way)
- Most connections are **bidirectional** (A → B and B → A)
- Check both `connectedTo` arrays for two-way travel

```javascript
function canTravelBetweenVents(fromVentId, toVentId) {
  const fromVent = vents.find(v => v.id === fromVentId);
  return fromVent.connectedTo.includes(toVentId);
}
```

#### Entry/Exit Range
```javascript
const VENT_INTERACTION_RANGE = 10.0; // pixels

function canEnterVent(playerX, playerY, vent) {
  const distance = Math.sqrt(
    (playerX - vent.position.x) ** 2 + 
    (playerY - vent.position.y) ** 2
  );
  return distance <= VENT_INTERACTION_RANGE;
}
```

#### Vent Networks (The Skeld)
The map typically has **4 separate vent networks**:

1. **West Network:** Upper Engine ↔ Lower Engine ↔ Reactor
2. **Central Network:** MedBay ↔ Electrical ↔ Security  
3. **East Network:** Navigation ↔ Weapons ↔ Shields
4. **Cafeteria Network:** Cafeteria ↔ Admin

#### Implementation Example
```javascript
class VentSystem {
  constructor(vents) {
    this.vents = new Map(vents.map(v => [v.id, v]));
  }
  
  getConnectedVents(ventId) {
    const vent = this.vents.get(ventId);
    return vent.connectedTo.map(id => this.vents.get(id));
  }
  
  canUseVent(playerX, playerY, ventId) {
    const vent = this.vents.get(ventId);
    const distance = Math.sqrt(
      (playerX - vent.position.x) ** 2 + 
      (playerY - vent.position.y) ** 2
    );
    return distance <= 10.0;
  }
  
  enterVent(playerId, ventId) {
    // Hide player from map
    // Show vent UI with connected vents
    // Disable external vision
  }
  
  exitVent(playerId, ventId) {
    const vent = this.vents.get(ventId);
    // Teleport player to vent.position
    // Play exit animation (0.3s)
    // Return to normal gameplay
  }
}
```

#### Timing Constants
- **Entry Animation:** 0.3 seconds
- **Exit Animation:** 0.3 seconds
- **Travel Time:** Instant (no transit animation between vents)
- **Cooldown:** ~2 seconds between vent uses
- **Vision in Vents:** Zero external vision, can only see vent UI

---

## 6. Doors (Impostor Sabotage)

```json
"doors": [
  {
    "position": {"x": 800.0, "y": 600.0},
    "orientation": "horizontal",
    "room": "Cafeteria"
  }
]
```

### Fields

| Field | Type | Description |
|-------|------|-------------|
| `position` | `Point` | Center position of the door |
| `orientation` | `string` | `"horizontal"` or `"vertical"` |
| `room` | `string` | Associated room name (for context) |

### Door Mechanics

#### States
- **OPEN** (default): Players can pass through
- **CLOSED** (sabotaged): Players cannot pass through

#### Collision When Closed
```javascript
const DOOR_WIDTH = 50; // pixels (adjust based on map scale)
const DOOR_HEIGHT = 10; // pixels (for horizontal doors)

function isDoorBlocking(playerX, playerY, door) {
  if (door.state === 'OPEN') return false;
  
  if (door.orientation === 'horizontal') {
    // Check if player crosses horizontal door
    return Math.abs(playerY - door.position.y) < DOOR_HEIGHT &&
           Math.abs(playerX - door.position.x) < DOOR_WIDTH / 2;
  } else {
    // Check if player crosses vertical door
    return Math.abs(playerX - door.position.x) < DOOR_HEIGHT &&
           Math.abs(playerY - door.position.y) < DOOR_WIDTH / 2;
  }
}
```

#### Sabotage Timing
- **Duration:** 10 seconds (auto-opens after timer)
- **Cooldown:** 10-30 seconds ship-wide (cannot close any door)
- **Crisis Override:** All doors auto-open when Reactor/O2 sabotage is fixed
- **Multiple Doors:** Can close multiple doors simultaneously

#### Strategic Door Count (The Skeld)
- **Cafeteria:** 5 doors (maximum isolation potential)
- **Storage:** 2 doors (trap capability)
- **MedBay:** 1 door (single entry/exit)
- **Security:** 1 door (single entry/exit)

---

## 7. Tasks (Crewmate Objectives)

```json
"tasks": [
  {
    "type": "Divert Power",
    "position": {"x": 706.76, "y": 379.04},
    "room": "Upper Engine"
  }
]
```

### Fields

| Field | Type | Description |
|-------|------|-------------|
| `type` | `string` | Task type name (see Task Types below) |
| `position` | `Point` | Interaction position on the map |
| `room` | `string` | Associated room name |

### Task Types

#### Short Tasks (1-5 seconds)
- `"Swipe Card"` - Admin (2-3s)
- `"Prime Shields"` - Shields (3s)
- `"Empty Garbage"` - Cafeteria/O2 (2s)
- `"Chart Course"` - Navigation (3s)
- `"Stabilize Steering"` - Navigation (2s)
- `"Unlock Manifolds"` - Reactor (4s)
- `"Clean O2 Filter"` - O2 (4s)
- `"Divert Power"` - Electrical (2s, stage 1)
- `"Accept Power"` - Various rooms (1s, stage 2)

#### Long Tasks (10-60 seconds)
- `"Start Reactor"` - Reactor (10s)
- `"Submit Scan"` - MedBay (10s) **VISUAL**
- `"Inspect Sample"` - MedBay (60s)
- `"Fuel Engines"` - Storage→Engines (20s total)
- `"Upload Data"` - Admin (9s)
- `"Download Data"` - Various (9s)
- `"Clear Asteroids"` - Weapons (20s) **VISUAL**
- `"Fix Wiring"` - Various (3s × 3 panels)
- `"Calibrate Distributor"` - Electrical (3s)
- `"Align Engine Output"` - Upper/Lower Engine (3s × 2)

### Task Interaction

#### Range Check
```javascript
const TASK_INTERACTION_RANGE = 15.0; // pixels

function canInteractWithTask(playerX, playerY, task) {
  const distance = Math.sqrt(
    (playerX - task.position.x) ** 2 + 
    (playerY - task.position.y) ** 2
  );
  return distance <= TASK_INTERACTION_RANGE;
}
```

#### Visual Tasks
Tasks marked **VISUAL** have visible animations that prove completion:
- `"Submit Scan"` - Green scanner light visible to all players
- `"Clear Asteroids"` - Weapon firing visible through window
- `"Prime Shields"` - Shield hexagons glow visible on exterior

#### Multi-Stage Tasks
Some tasks require multiple interactions:

**Divert Power (2 stages):**
1. Electrical: Slide power lever up
2. Target Room: Click fuse to accept power

**Fuel Engines (multiple trips):**
1. Storage: Fill gas can
2. Upper Engine: Deposit fuel
3. Storage: Fill gas can again
4. Lower Engine: Deposit fuel

**Fix Wiring (3 stages):**
1. Location A: Connect wires
2. Location B: Connect wires  
3. Location C: Connect wires

```javascript
class Task {
  constructor(data) {
    this.type = data.type;
    this.position = data.position;
    this.room = data.room;
    this.currentStage = 0;
    this.totalStages = this.getStageCount();
  }
  
  getStageCount() {
    if (this.type === 'Fix Wiring') return 3;
    if (this.type === 'Divert Power') return 2;
    if (this.type === 'Fuel Engines') return 4;
    if (this.type === 'Align Engine Output') return 2;
    return 1;
  }
  
  complete() {
    this.currentStage++;
    return this.currentStage >= this.totalStages; // true if fully complete
  }
}
```

### Task Assignment
- **Common Tasks:** 0-2 (all crewmates get same ones)
- **Long Tasks:** 0-3 per player
- **Short Tasks:** 0-5 per player
- **Total:** Usually 4-8 tasks per crewmate

### Task Progress Bar
```javascript
function calculateTaskProgress(completedSubtasks, totalSubtasks) {
  return (completedSubtasks / totalSubtasks) * 100;
}

// Task bar fills incrementally as each subtask completes
// Dead crewmates can continue completing tasks as ghosts
// Task win disabled during active sabotage crises
```

---

## 8. Cameras (Security System)

```json
"cameras": [
  {
    "position": {"x": 1500.0, "y": 800.0},
    "direction": 90.0,
    "visionRange": 300.0,
    "visionAngle": 60.0
  }
]
```

### Fields

| Field | Type | Description |
|-------|------|-------------|
| `position` | `Point` | Camera mount position |
| `direction` | `number` | Facing direction in degrees (0° = right, 90° = down, 180° = left, 270° = up) |
| `visionRange` | `number` | Maximum vision distance in pixels |
| `visionAngle` | `number` | Field of view angle in degrees (e.g., 60° cone) |

### Camera Vision Cone

```javascript
function isPlayerVisibleOnCamera(playerX, playerY, camera) {
  // 1. Distance check
  const dx = playerX - camera.position.x;
  const dy = playerY - camera.position.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  
  if (distance > camera.visionRange) return false;
  
  // 2. Angle check
  const angleToPlayer = Math.atan2(dy, dx) * 180 / Math.PI;
  const angleDiff = Math.abs(angleToPlayer - camera.direction);
  
  // Normalize angle difference to -180 to 180
  const normalizedDiff = ((angleDiff + 180) % 360) - 180;
  
  if (Math.abs(normalizedDiff) > camera.visionAngle / 2) return false;
  
  // 3. Line of sight check (walls block vision)
  if (isBlockedByWalls(camera.position, {x: playerX, y: playerY})) {
    return false;
  }
  
  return true;
}
```

### The Skeld Camera Locations
1. **Navigation Corridor** - Monitors Nav/Shields area
2. **Admin Corridor** - Monitors Admin/Cafeteria area  
3. **Security Entrance** - Monitors Security hallway
4. **MedBay Entrance** - Monitors MedBay hallway

### Security Monitor
- **Location:** Security room
- **Simultaneous Views:** Can cycle through all cameras
- **Visual Indicator:** Red light blinks when cameras are being viewed
- **Communications Sabotage:** Disables all cameras

---

## Game Mechanics Implementation

### Movement Speed
```javascript
const BASE_SPEED = 5.5; // pixels per second at 1.0x speed
const SPEED_MULTIPLIER = 1.0; // Game setting (0.5x - 3.0x)

function updatePlayerPosition(deltaTime) {
  const moveDistance = BASE_SPEED * SPEED_MULTIPLIER * deltaTime;
  // Apply to player position
}
```

### Vision System

#### Vision Formula
```javascript
visibleDistance = BASE_VISION × VISION_MULTIPLIER × ENVIRONMENTAL_MODIFIER

// Crewmate Vision: 0.25x - 5.0x (game setting)
// Impostor Vision: Usually +0.5x to +1.5x bonus
// Lights Sabotage: Crewmate vision × 0.25, Impostor unchanged
```

#### Fog of War
```javascript
function calculateVisibility(distance, visionRadius) {
  if (distance <= visionRadius * 0.7) {
    return 1.0; // Full visibility
  } else if (distance <= visionRadius) {
    // Gradual fade from 70% to 100% of radius
    const fadeStart = visionRadius * 0.7;
    const fadeLength = visionRadius * 0.3;
    return 1.0 - ((distance - fadeStart) / fadeLength);
  } else {
    return 0.0; // Complete darkness
  }
}
```

### Kill Mechanics

#### Kill Distances
```javascript
const KILL_RANGE_SHORT = 10.0;   // pixels
const KILL_RANGE_MEDIUM = 18.0;  // pixels
const KILL_RANGE_LONG = 25.0;    // pixels

function canKillTarget(killerX, killerY, targetX, targetY, killRange) {
  const distance = Math.sqrt(
    (targetX - killerX) ** 2 + 
    (targetY - killerY) ** 2
  );
  return distance <= killRange;
}
```

#### Kill Cooldown
- **Range:** 10-60 seconds (game setting)
- **Typical:** 25-45 seconds
- **Animation Duration:** 0.5 seconds (killer frozen)

#### Body Reporting
```javascript
const REPORT_RANGE = 25.0; // pixels

function canReportBody(playerX, playerY, bodyX, bodyY) {
  const distance = Math.sqrt(
    (bodyX - playerX) ** 2 + 
    (bodyY - playerY) ** 2
  );
  return distance <= REPORT_RANGE;
}
```

### Sabotage Mechanics

#### Reactor Meltdown / O2 Depletion
```javascript
class CriticalSabotage {
  constructor(type, duration = 45) {
    this.type = type; // 'reactor' or 'oxygen'
    this.duration = duration; // seconds
    this.timeRemaining = duration;
    this.fixLocations = this.getFixLocations();
    this.fixedCount = 0;
  }
  
  getFixLocations() {
    if (this.type === 'reactor') {
      return [
        {x: 400, y: 850, name: 'Reactor Left Panel'},
        {x: 500, y: 850, name: 'Reactor Right Panel'}
      ];
    } else {
      return [
        {x: 1800, y: 900, name: 'O2 Panel'},
        {x: 1200, y: 1100, name: 'Admin Panel'}
      ];
    }
  }
  
  fix(location) {
    this.fixedCount++;
    if (this.fixedCount >= this.fixLocations.length) {
      this.resolved = true;
      return true; // Sabotage fixed
    }
    return false; // Need more fixes
  }
  
  update(deltaTime) {
    if (!this.resolved) {
      this.timeRemaining -= deltaTime;
      if (this.timeRemaining <= 0) {
        // Impostors win
        return 'IMPOSTOR_WIN';
      }
    }
  }
}
```

#### Lights Sabotage
```javascript
class LightsSabotage {
  constructor() {
    this.active = false;
    this.fixLocation = {x: 950, y: 800}; // Electrical panel
  }
  
  activate() {
    this.active = true;
    // Reduce crewmate vision to 0.25x
    // Impostor vision unchanged
  }
  
  fix() {
    this.active = false;
    // Restore normal vision
  }
}
```

### Collision System

```javascript
class CollisionSystem {
  constructor(walkableZones) {
    this.walkableZones = walkableZones;
  }
  
  canMove(fromX, fromY, toX, toY) {
    // Check if destination is valid
    if (!this.isWalkable(toX, toY)) {
      return false;
    }
    
    // Check if path crosses any boundaries
    for (const zone of this.walkableZones) {
      if (this.lineCrossesPolygonBoundary(fromX, fromY, toX, toY, zone.vertices)) {
        return false;
      }
      
      for (const hole of zone.holes) {
        if (this.lineCrossesPolygonBoundary(fromX, fromY, toX, toY, hole)) {
          return false;
        }
      }
    }
    
    return true;
  }
  
  isWalkable(x, y) {
    for (const zone of this.walkableZones) {
      if (this.pointInPolygon(x, y, zone.vertices)) {
        // Inside zone boundary, check if not in a hole
        for (const hole of zone.holes) {
          if (this.pointInPolygon(x, y, hole)) {
            return false; // Inside a hole (obstacle)
          }
        }
        return true; // In walkable zone, not in hole
      }
    }
    return false; // Not in any walkable zone
  }
  
  pointInPolygon(x, y, vertices) {
    let inside = false;
    for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
      const xi = vertices[i].x, yi = vertices[i].y;
      const xj = vertices[j].x, yj = vertices[j].y;
      
      const intersect = ((yi > y) !== (yj > y))
          && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }
  
  lineCrossesPolygonBoundary(x1, y1, x2, y2, vertices) {
    for (let i = 0; i < vertices.length; i++) {
      const j = (i + 1) % vertices.length;
      if (this.lineSegmentsIntersect(
        x1, y1, x2, y2,
        vertices[i].x, vertices[i].y,
        vertices[j].x, vertices[j].y
      )) {
        return true;
      }
    }
    return false;
  }
  
  lineSegmentsIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
    const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
    if (denom === 0) return false; // Parallel
    
    const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
    const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
    
    return (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1);
  }
}
```

---

## Performance Optimization

### Spatial Partitioning
```javascript
class SpatialGrid {
  constructor(mapWidth, mapHeight, cellSize = 100) {
    this.cellSize = cellSize;
    this.grid = new Map();
    this.mapWidth = mapWidth;
    this.mapHeight = mapHeight;
  }
  
  getCellKey(x, y) {
    const cellX = Math.floor(x / this.cellSize);
    const cellY = Math.floor(y / this.cellSize);
    return `${cellX},${cellY}`;
  }
  
  insert(entity) {
    const key = this.getCellKey(entity.x, entity.y);
    if (!this.grid.has(key)) {
      this.grid.set(key, []);
    }
    this.grid.get(key).push(entity);
  }
  
  getNearby(x, y, radius) {
    const nearby = [];
    const minCellX = Math.floor((x - radius) / this.cellSize);
    const maxCellX = Math.floor((x + radius) / this.cellSize);
    const minCellY = Math.floor((y - radius) / this.cellSize);
    const maxCellY = Math.floor((y + radius) / this.cellSize);
    
    for (let cx = minCellX; cx <= maxCellX; cx++) {
      for (let cy = minCellY; cy <= maxCellY; cy++) {
        const key = `${cx},${cy}`;
        if (this.grid.has(key)) {
          nearby.push(...this.grid.get(key));
        }
      }
    }
    
    return nearby;
  }
}
```

### Caching Polygon Bounds
```javascript
class PolygonBounds {
  static getBounds(vertices) {
    const xs = vertices.map(v => v.x);
    const ys = vertices.map(v => v.y);
    return {
      minX: Math.min(...xs),
      maxX: Math.max(...xs),
      minY: Math.min(...ys),
      maxY: Math.max(...ys)
    };
  }
  
  static quickReject(x, y, bounds) {
    return x < bounds.minX || x > bounds.maxX ||
           y < bounds.minY || y > bounds.maxY;
  }
}
```

---

## Version History

### Version 2.0 (Current)
- Added `labeledZones` for player location detection
- Added `holes` to `walkableZones` for obstacle polygons
- Deprecated `isRoom` and `roomName` in `walkableZones`
- Deprecated `walls` array (now implicit from walkable zones)

### Version 1.0 (Legacy)
- Basic `walls`, `rooms`, `hallways`, `playerZones`
- No hole support
- No labeled zones

---

## Example Implementation

```javascript
class AmongUsMap {
  constructor(jsonData) {
    this.metadata = jsonData.metadata;
    this.walkableZones = jsonData.walkableZones;
    this.labeledZones = jsonData.labeledZones;
    this.vents = new Map(jsonData.vents.map(v => [v.id, v]));
    this.doors = jsonData.doors;
    this.tasks = jsonData.tasks;
    this.cameras = jsonData.cameras;
    
    this.collision = new CollisionSystem(this.walkableZones);
    this.spatialGrid = new SpatialGrid(3000, 2000, 100);
  }
  
  canPlayerMoveTo(fromX, fromY, toX, toY) {
    return this.collision.canMove(fromX, fromY, toX, toY);
  }
  
  getPlayerLocation(x, y) {
    for (const zone of this.labeledZones) {
      if (this.collision.pointInPolygon(x, y, zone.vertices)) {
        return zone.name;
      }
    }
    return "Unknown";
  }
  
  getNearbyTasks(x, y, range = 15.0) {
    return this.tasks.filter(task => {
      const dist = Math.sqrt(
        (task.position.x - x) ** 2 + 
        (task.position.y - y) ** 2
      );
      return dist <= range;
    });
  }
  
  getNearbyVents(x, y, range = 10.0) {
    return Array.from(this.vents.values()).filter(vent => {
      const dist = Math.sqrt(
        (vent.position.x - x) ** 2 + 
        (vent.position.y - y) ** 2
      );
      return dist <= range;
    });
  }
}

// Usage
const mapData = await fetch('maps/json/skeld.json').then(r => r.json());
const map = new AmongUsMap(mapData);

// Player movement
if (map.canPlayerMoveTo(player.x, player.y, newX, newY)) {
  player.x = newX;
  player.y = newY;
}

// Location detection
const location = map.getPlayerLocation(player.x, player.y);
console.log(`Player is in: ${location}`);

// Interaction detection
const nearbyTasks = map.getNearbyTasks(player.x, player.y);
if (nearbyTasks.length > 0) {
  showTaskPrompt(nearbyTasks[0]);
}
```

---

## Conclusion

This specification provides complete implementation details for the Among Us map JSON format. All distances are in pixels, polygons use standard point-in-polygon algorithms, and game mechanics follow the original Among Us specifications from `agents.md`.

For additional details on game mechanics, movement physics, and AI strategy, refer to the `agents.md` file in the repository root.
